.. _`mapfish.tutorials.studio_developer_guide`:

Studio - Developer Guide (BETA)
===============================

This document contains instructions for Studio developers.

Install Dependencies
--------------------

Studio has two types of dependencies: pure Python dependencies, and system dependencies. Pure Python
dependencies will be installed as part of the installation of Studio. System dependencies, listed
below, are installed separately.

* Python 2.5
* MapServer CGI, version 5.0 and higher
* MapServer MapScript Python, version 5.0 and higher
* OGRGDAL Python, version 1.5 and higher
* Java JRE version 1.5.0 and higher (only needed if you want to enable printing)

On a Linux system, you can rely on your distribution packages (recommanded).
For example, on Debian-like system, you would install the packages with::

    sudo apt-get install gcc libc6-dev libpq-dev python2.5 python2.5-dev libgeos-dev cgi-mapserver python-mapscript python-gdal postgresql postgis sun-java6-bin

On a Windows system, you would need to install Python 2.5 from
http://www.python.org/download/releases/ and its pywin32 (a.k.a win32api)
extension from http://sourceforge.net/project/showfiles.php?group_id=78018. You
would rely on the MS4W distribution from http://www.maptools.org/ms4w/ for
MapServer and OGRDAL.

On a Debian system, you can check that MapServer CGI works locally by testing the following URL in a browser (you should receive the answer "No query information to decode. QUERY_STRING is set, but empty." )::

    http://localhost/cgi-bin/mapserv

Install Studio from SVN
-----------------------

It is highly recommended to install Studio in a virtual environment, so you'll start with that.

Set up a Virtual Python Environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here is the procedure on a Debian-like computer. Create first a directory::

 mkdir studiodev
 cd studiodev

**Note**
    If you already have the ``easy_install`` (if it is not the case: sudo apt-get install python-setuptools) program installed, you can install ``virtualenv`` using::

        easy_install virtualenv

Unix users will use this in order to create a python virtual environment::

  wget http://www.mapfish.org/downloads/virtualenv-1.3.4.py
  python2.5 virtualenv-1.3.4.py venv

Windows users will download the file and create a virtual env with::

    C:\>C:\Python25\python.exe "C:\Documents and Settings\Administrator\virtualenv-1.3.4.py" C:\env
    New python executable in C:\env\Scripts\python.exe
    Installing setuptools..............done.

You can now activate the virtual environment::

  source venv/bin/activate

On a Windows system::

    C:\> env\Scripts\activate.bat

Install
^^^^^^^

Install the necessary basic library::

  sudo apt-get install gcc libc6-dev libpq-dev python2.5 python2.5-dev libgeos-dev cgi-mapserver python-gdal postgresql postgis sun-java6-bin

MapScript can't be installed through easy_install, so it is needed to do the following procedure to install it::

  sudo apt-get install python-mapscript
  cp /usr/lib/python2.5/site-packages/_mapscript.so venv/lib/python2.5/site-packages/
  cp /usr/share/pyshared/mapscript.py venv/lib/python2.5/site-packages/

If you are not using python 2.5, you probably need to change the 'python2.5' directory name.

Currently the Studio source tree is located in a MapFish sandbox http://www.mapfish.org/svn/mapfish/sandbox/camptocamp/Studio

You can check out the source tree with::

    svn co http://www.mapfish.org/svn/mapfish/sandbox/camptocamp/Studio

Install MapFish (python server component)::

  svn checkout http://www.mapfish.org/svn/mapfish/framework/server/trunk server
  easy_install --index-url=http://dev.camptocamp.com/packages/mapfish/all/index --allow-hosts=dev.camptocamp.com server

Install pycopg2::

  easy_install --index-url=http://dev.camptocamp.com/packages/mapfish/all/index --allow-hosts=dev.camptocamp.com psycopg2  

Install MapFish Client plug-in::

  svn checkout http://www.mapfish.org/svn/mapfish/framework/plugin/client/trunk plugin-client
  easy_install --index-url=http://dev.camptocamp.com/packages/mapfish/all/index --allow-hosts=dev.camptocamp.com plugin-client

Now that you have a virtual Python environment ready, you can proceed with the installation of Studio with::

    cd Studio

You need first to adapt the connexion to the PostGIS database in studio/config/environment.py, with something like (a connexion to a database used to store your data and accessible thourgh www-data)::

    # path to default postgis datastore
    config['default_datastore_postgis'] = "PG:host=localhost dbname=studio user=www-data password=www-data"

Then, setup your environment::

    python setup.py develop

This will install Studio and its dependencies.

And, in order to create the Studio metadata database, start::

    paster setup-app development.ini

And compile the catalog to pepare the translations::

   python setup.py compile_catalog

Then, you can test Studio by starting it::

    paster serve --reload development.ini

And login in http://localhost:5000 (the password of admin user is set in development.ini)

Two user accounts have been created by default:

* Admin user is the master user. He owns all permissions.
    * login: ``admin``
    * password: ``change_this_password``
* Enduser is a standard user. He owns all permissions except those to add/update/view datastores.
    * login: ``enduser``
    * password: ``password``

If something goes wrong, try to replace all mention to "mapfish.framework.plugins.client" by "mapfish.plugin.client" in directory studiodev, recursively.

Run the tests
-------------

To run the unit and functional tests run the ``nosetests`` command at the root of the project directory (the
Studio directory)::

    $ nosetests -d

The ``nosetests`` documentation gives this for the ``-d`` switch::

     Add detail to error output by attempting to evaluate
     failed asserts [NOSE_DETAILED_ERRORS]

Authentication and authorisation
--------------------------------

The authentication and authorisation system is based on the repoze middleware
(repoze.who and repose.what).

Authentication is based on the following database tables :

* ``user`` : this table contains users (id, user name, login, password)

* ``group`` : this table contains groups (id, group name) and is linked to table 'user' in [n..n] relation

* ``permission`` : this table contains permissions (id, permission name) and is linked to table 'group' in
  [n..n] relation

The authorisation system will then allow a response based on group membership or permission check.
In practical terms, you need to populate the database with some groups and permissions, then link each group
with a set of permissions.

Once this is done, you will be able to allow or deny every action of
controllers, using the ``@ActionProtector`` decorator and using built-in or custom
predicates. You will find some good documentation on predicates, and a list of
built-in predicates here:

    http://what.repoze.org/docs/1.x/Manual/

So let's go with a simple example. Imagine we want to deny access to action ``delete`` of our controller
``UsersController`` to all users except those who have the permission 'delete users'.
We simply need to add the decorator ``@ActionProtector`` with the build-in predicate
``has_permission('delete users')`` to our ``delete`` action::

    from repoze.what.predicates import has_permission
    from repoze.what.plugins.pylonshq import ActionProtector

    class UsersController(BaseController):

        @ActionProtector(has_permission('delete users'))
        def delete(self):
            # [ ... ]
            return 'User deleted'

If the predicate ``has_permission('delete users')`` is not fulfilled, a 401 or 403 error will be returned.

You may also need to know the identity of the user logged in. You can achieve this by looking at
``repoze.what.credentials`` environnement variable.
So the user login is accessible via::

    request.environ.get('repoze.what.credentials')['repoze.what.userid']

HTTP Interfaces
---------------

This section describes the HTTP Interfaces the server side of Studio exposes.

datastores
^^^^^^^^^^

Get the list of datastores
~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores``
* response: a JSON document of this form:

.. code-block:: javascript

    { "datastores": [
        {
            "text": "{datastore_name}",
            "href": "{datastore_href}",
            "id": "{datastore_id}"
        },
        ...
    ]} 

* success status code: ``200 OK``
* manual test: ``curl -X GET http://localhost:5000/datastores``

Get the information of a given datastore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores/{datastore_id}``
* response: a JSON document of this form:

.. code-block:: javascript

    {
        "type": "{datastore_type}",
        "id": "{datastore_id}",
        "ogrstring": "{datastore_ogrstring}",
        "name": "{datastore_name}"
    }

* Note: {datastore_type} is a string representing the type of datastore (ie. [directory|postgis])
* success status code: ``200 OK``
* manual test: ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852``

Create a new datastore
~~~~~~~~~~~~~~~~~~~~~~

* request: ``POST /datastores``
* request body for a "directory" datastore:

.. code-block:: javascript

    {
        "name": "{datastore_name}",
        "type": "directory",
        "ogrstring": "path/to/directory"
    }

* request body for a "database" datastore:

.. code-block:: javascript

    {
        "name": "{datastore_name}",
        "type": "postgis",
        "ogrstring": "PG: host=localhost port=5433 user=www-data password=www-data dbname=pref"
    }

* success status code: ``201 CREATED``

Update an existing datastore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``PUT /datastores/{datastore_id}``
* request body for a "directory" datastore:

.. code-block:: javascript

    {
        "name": "{datastore_name}",
        "type": "directory",
        "ogrstring": "path/to/directory"
    }

* request body for a "database" datastore:

.. code-block:: javascript

    {
        "name": "{datastore_name}",
        "type": "postgis",
        "ogrstring": "PG: host=localhost port=5433 user=www-data password=www-data dbname=pref"
    }

* success status code: ``201 CREATED``

Delete an existing datastore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``DELETE /datastores/{datastore_id}``
* success status code: ``204 No Content``

datasources
^^^^^^^^^^^

Get the list of datasources within a given datastore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores/{datastore_id}/datasources``
* response body:

.. code-block:: javascript

    { "datasources": [
        {
            "text": "{datasource_name}",
            "href": "{datasource_href}",
            "id": "{datasource_id}",
            "type": "[RASTER|POINT|LINE|POLYGON]",
            "leaf": true
        },
        ...
    ]} 

* Note: ``{datasource_id}`` is a hash representing the datasource
* success status code: ``200 OK``
* manual test: ``curl -X GET http://localhost:5000/datastores/1/datasources``

Get the information of a given datasource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores/{datastore_id}/datasources/{datasource_id}``
* ``{datasource_id}`` is a hash representing the datasource
* success status code: ``200 OK``
* manual test: ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852``

Get the mapfile excerpt for the given datasource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores/{datastore_id}/datasources/{datasource_id}/mapfile[?classificationparams=....]``
* manual test: ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/mapfile``
* Note: if the ``classificationparams`` parameter is present, returns a mapfile
  excerpt for the thematized layer. Parameters should include:

  * ``classification=quantile|unique`` : what type of classification to apply
  * ``attribute={column}`` : must be on an numeric column for quantile classification
  * ``intervals=[integer]`` : number of classes (applies only for quantile classification
  * ``colortype=ramp|qualitative``

    * ramp: interpolate between a start and end color:
      
      * startcolor=rrggbb : first color in ramp, in hexadecimal format without leading #
      * endcolor=rrggbb : last color in ramp, in hexadecimal format without leading #
      * interpolation=RGB|HSV : in wich colorspace should the interpolation be done
    
    * qualitative: use a predefined palette:

      * theme=0|1|2.....|7 : which predefined palette to use

  * ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/mapfile?classification=quantile&startcolor=ff0000&endcolor=0000ff&attribute=POP2005&intervals=5``
  * ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/mapfile?classification=quantile&colortype=ramp&interpolation=HSV&startcolor=ff2200&endcolor=0022ff&attribute=POP2005&intervals=7``
  * ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/mapfile?classification=quantile&colortype=qualitative&theme=0&attribute=POP2005&intervals=5``
  * ``curl -x GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/mapfile?classification=unique&colortype=qualitative&theme=0&attribute=REGION``

* response: a JSON document representing a default mapfile layer excerpt for this datasource
* success status code: ``200 OK``

Get the columns of a given datasource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /datastores/{datastore_id}/datasources/{datasource_id}/columns``
* success status code: ``200 OK``
* response body:

.. code-block:: javascript

    { "columns": [
        {
            "name":"columname",
            "type":"string|numeric"
        },
        ...
    ]}

* manual test: ``curl -X GET http://localhost:5000/datastores/1/datasources/3dfa880a8e37bcc97ff8bbeb9aff7852/columns``

Create a new datasource
~~~~~~~~~~~~~~~~~~~~~~~
This action creates a new datasource within a given datastore by file
upload. The request body must contains a single parameter ``datasources`` that
contains the datasource, the parameter Content-Disposition must be ``form-data``.
This file can be a single file, a zip or a tar archive.

* request: ``POST /datastores/{datastore_id}/datasources/``
* success status code: ``201 CREATED``

mapfiles
^^^^^^^^

Get an empty mapfile skeleton
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles/default``
* response: a JSON document representing a mapfile

Get the list of mapfiles
~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles``
* response: a JSON document of this form:

.. code-block:: javascript

    { "maps": [
        {
            "id": "{mapfile_id}",
            "href": "{mapfile_href}",
            "name": "{mapfile_name}"
        },
        ...
    ]}

* success status code: ``200 OK``

Get an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles/{mapfile_id}``
* response: a JSON document representing a mapfile
* success status code: ``200 OK``

Get symbols from an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles/{mapfile_id}/symbols``
* response: a JSON document representing symbols of a mapfile:

.. code-block:: javascript

    { "symbols": [
        {
            "id": 1,
            "name": "dash"
        },
        {
            "id": 2,
            "name": "parking"
        },
        ...
    ]}

* success status code: ``200 OK``

Get fonts from an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles/{mapfile_id}/fonts``
* response: a JSON document representing fonts of a mapfile:

.. code-block:: javascript

    { "fonts": [
        {
            "id": "verdana",
            "name": "verdana"
        },
        {
            "id": "arial",
            "name": "arial"
        },
        ...
    ]}

* success status code: ``200 OK``

Download an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /mapfiles/{mapfile_id}/download``
* response: return the mapfile as an attachment (browser should ask for opening 
  file with an external editor)
* success status code: ``200 OK``

Create a new mapfile
~~~~~~~~~~~~~~~~~~~~

* request: ``POST /mapfiles``
* request body: a JSON document representing a mapfile
* success status code: ``201 CREATED``
* response: a JSON document of this form:

.. code-block:: javascript

    {
        "id": "{mapfile_id}",
        "href": "{mapfile_href}",
        "name": "{mapfile_name}"
    }

Update an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``PUT /mapfiles/{mapfile_id}``
* request body: a JSON document representing a mapfile
* success status code: ``201 CREATED``

Delete an existing mapfile
~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``DELETE /mapfiles/{mapfile_id}``
* success status code: ``204 No Content``

layertemplates
^^^^^^^^^^^^^^

Get the list of layertemplates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /layertemplates``
* response: a JSON document of this form:

.. code-block:: javascript

    { "layertemplates": [
        {
            "id": "{layertemplate_id}",
            "href": "{layertemplate_href}",
            "name": "{layertemplate_name}",
            "comment": "{layertemplate_comment}"
        },
        ...
    ]}

* success status code: ``200 OK``

Get an existing layertemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /layertemplates/{layertemplate_id}``
* response: a JSON document of this form:

.. code-block:: javascript

    {
        "id": "{layertemplate_id}",
        "name": "{layertemplate_name}",
        "comment": "{layertemplate_comment}",
        "user_id": "{layertemplate_user_id}",
        "json": {
            // the json representing the layer template
        }
    }

* success status code: ``200 OK``

Create a new layertemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``POST /layertemplates``
* request body: a JSON document of this form:

.. code-block:: javascript

    {
        "name": "{layertemplate_name}",
        "comment": "{layertemplate_comment}",
        "json": {
            // the json representing the layer template
        }
    }

* success status code: ``201 CREATED``
* response: a JSON document of this form:

.. code-block:: javascript

    {
        "id": "{layertemplate_id}",
        "href": "{layertemplate_href}",
        "name": "{layertemplate_name}",
        "comment": "{layertemplate_comment}"
    }

Update an existing layertemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``PUT /layertemplates/{layertemplate_id}``
* request body: a JSON document of this form:

.. code-block:: javascript

    {
        "name": "{layertemplate_name}",
        "comment": "{layertemplate_comment}",
        "json": {
            // the json representing the layer template
        }
    }

* success status code: ``201 CREATED``

Delete an existing layertemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``DELETE /layertemplates/{layertemplate_id}``
* success status code: ``204 No Content``

started_mapfishes
^^^^^^^^^^^^^^^^^

Start a MapFish application
~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``PUT /started_mapfishes/{id}``
* success status code: ``201 CREATED``

Stop a MapFish application
~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``DELETE /started_mapfishes/{id}``
* success status code: ``204 No Content``

Get the status of a MapFish application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* request: ``GET /started_mapfishes/{id}``
* status code: ``200 OK`` if the application is started, ``404 NOT FOUND`` if it is stopped

Style Panels
------------

FillStylePanel.js
^^^^^^^^^^^^^^^^^

For polygon layers.

Properties:
 * color
 * opacity
 * angle
 * symbol
 * size
 * width

LabelStylePanel.js
^^^^^^^^^^^^^^^^^^

For all layers.

Properties:
 * angle
 * font
 * size
 * priority
 * buffer
 * color
 * outlinecolor
 * position

PointStylePanel.js
^^^^^^^^^^^^^^^^^^

For point and annotation layers.

Properties:
 * color
 * outlinecolor
 * size
 * angle
 * symbol

StrokeStylePanel.js
^^^^^^^^^^^^^^^^^^^

For polygon and line layers.

Properties:
 * color
 * outlinecolor
 * width
 * symbol


